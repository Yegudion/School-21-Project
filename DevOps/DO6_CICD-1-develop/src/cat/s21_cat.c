#include "s21_cat.h"

// программа воспроизводит работу функции cat
int main(int argc, char** argv) {
  // таблица на основе атрибутов структуры
  cat_fl cat_flags = {0};
  // вызов ф. парсинга флагов из массива строк argv
  flags_parser(argc, argv, &cat_flags);
  // вызов ф. обработки принятых парсером аргументов argv
  processing_accepted_arguments(argc, argv, &cat_flags);
  return 0;
}

// ф. парсинга флагов из массива строк
int flags_parser(int argc, char** argv, cat_fl* cat_flags) {
  // цикл 1 уровня: просмотра строк массива
  for (int i = 1; i < argc; i++) {
    // цикл 2 ур.: просм. симв. стр. масс., начиная с 1-го, если 0-ой это '-'
    for (size_t j = 1; j < (strlen(*(argv + i))) && (argv[i][0] == '-'); j++) {
      // перем. для приема просматриваемого симв. в просматриваемой строке
      char option = argv[i][j];
      // ветв. 1 ур. 'если' в цикле 2 ур.: просматриваемый  симв. это не '-', то
      if (argv[i][j] != '-') {
        // передача просматриваемого симв. в оператор ветв. для сравнения
        switch (option) {
          // значение 'b' - опция нумерует только непустые строки
          case 'b':
            cat_flags->b_min = 1;
            break;
          // значение 'e' - опция отображает непечатные символы (как опция -v),
          // а также отображает знак '$' в конце каждой строки
          case 'e':
            cat_flags->e_min = 1;
            // включить опцию 'v'
            cat_flags->v_min = 1;
            break;
          // значение 'E' - то же самое что и 'e', но без применения -v
          case 'E':
            cat_flags->E_min = 1;
            break;
          // нумерует все выходные строки
          case 'n':
            cat_flags->n_min = 1;
            break;
          // сжимает несколько смежных пустых строк
          case 's':
            cat_flags->s_min = 1;
            break;
          // значение 't' - опция отображает символы табуляции как '^I',
          // а также непечатные символы (как опция -v)
          case 't':
            cat_flags->t_min = 1;
            // включить опцию 'v'
            cat_flags->v_min = 1;
            break;
          // значение 'T' - то же самое что и 't', но без применения -v
          case 'T':
            cat_flags->T_min = 1;
            break;
          // значение 'v' - отображает непечатные символы так, чтобы они были
          // видны. Управляющие символы печатаются как '^X' для control-X;
          // символ удаления (восьмеричный 0177) печатается как '^?'.
          // Не-ASCII символы (с установленным старшим битом) печатаются как
          // 'M-' (для meta), за которым следует символ младших 7 бит.
          case 'v':
            cat_flags->v_min = 1;
            break;
          // сохраняет номер строки массива argv, значение которой не
          // соответствует ни одной из опций функции cat
          default:
            cat_flags->disapp = i;
            break;
        }
        // ветв. 1 ур. в ц. 2 ур.'иначе если': 1-ые 2 симв. 1 стр. масс. - это
        // '--'
      } else if (argv[1][0] == '-' && argv[1][1] == '-') {
        // ветв. 2 ур. в ц. 2 ур.'если': стр. 1 масс. соот-т указ. знач.
        if (strcmp("--number-nonblank", argv[1]) == 0) {
          cat_flags->b_min = 1;
          // ветв. 2 ур. в ц. 2 ур.'иначе если': стр. 1 масс. соот-т указ. знач.
        } else if (strcmp("--number", argv[1]) == 0) {
          cat_flags->n_min = 1;
          // ветв. 2 ур. в ц. 2 ур.'иначе если': стр. 1 масс. соот-т указ-у
          // знач.
        } else if (strcmp("--squeeze-blank", argv[1]) == 0) {
          cat_flags->s_min = 1;
          // ветв. 2 ур. в ц. 2 ур.'иначе' если: стр. 1 масс. argv при
          // первых двух симв. '--' не соотв-т знач-м, ук-ым выше
        } else {
          printf(
              "cat: illegal option -- -\nusage: cat [-benstuv] [file ...]\n");
          cat_flags->disapp = 0;
        }
      }
      // ветв. 1 ур. в цикле 2 ур.: 'если' вкл. опция 'b', то вык-ть опцию 'n'
      if (cat_flags->b_min == 1) {
        cat_flags->n_min = 0;
      }
      // ветв. 1 ур. в цикле 2 ур.: 'если': вкл. опция 'n', то вык-ть опцию 'b'
      // if (cat_flags->n_min == 1) {
      //   cat_flags->b_min = 0;
      // }
    }
  }
  return 0;
}

// функция обработки принятных парсером аргументов из массива argv
// в зависимости от соответствия значений поданных в argv опциям ф-ции cat
void processing_accepted_arguments(int argc, char** argv, cat_fl* cat_flags) {
  FILE* f_ptr = NULL;
  // ветв. 1 ур.'если': опции для функции cat были приняты парсером
  if (cat_flags->disapp == 0) {
    int i = 1;
    // ц. вывода файлов (арг. argv) поданных в масс. в stdout (на экран)
    while (i < argc) {
      file_character_printing(f_ptr, argv[i], cat_flags);
      i++;
    }
    // ветв. 1 ур.'иначе' если: опции для ф. cat не были приняты парсером
  } else {
    printf("s21_cat: illegal option -- %c\n", argv[cat_flags->disapp][1]);
    printf("usage: cat [-benstuv] [file ...]\n");
  }
}

// функция посимволного вывода содержимого файла в stdout
int file_character_printing(FILE* f_ptr, char* name_of_file,
                            cat_fl* cat_flags) {
  // переменная для приема символов читаемого файла
  int buf;
  // переменная-указатель для приема адреса открытого файла
  f_ptr = NULL;
  // переменная для приема количества пустых строк в файле
  int opt_s = 0;
  // переменная для приема результата булева выражения при нумерации строк
  int bool_ex = 0;
  // переменная для приема номера строки файла
  int num_str = 1;
  // ветвление 1 ур. выполнять 'если': 0-й символ имени файла - это не '-'
  if (name_of_file[0] != '-') {
    // передача адр. переменной-указателю на открытый целиком файл с указ-м реж.
    // чтения
    f_ptr = fopen(name_of_file, "rt");
    // ветвление 2 ур. выполнять 'если': имеется указатель на файл и
    // считываемый символ не равен значению конца файла, исключая ошибки чтен.
    // и пока нет других ошибoк прочтения
    if (f_ptr != NULL && feof(f_ptr) == 0 && ferror(f_ptr) == 0) {
      // цикл посимвольного считывания файла действует пока не конец файла
      while ((buf = getc(f_ptr)) != EOF) {
        // ветв. 3 ур.: обнулять перем-ю в ц. 'если'
        // чит-ый симв. - не кон. стр. иначе сох-ть ее знач.
        if (buf != '\n') opt_s = 0;
        // ветвление 3 ур. выполнять 'если' есть опция '-s'
        // и читаемый символ это конец строки
        if (cat_flags->s_min && buf == '\n') {
          // инкрементировать перем-ю
          opt_s++;
          // ветвление 4 ур. 'если' читаемый симв. соотв-т 2-й и более
          // пустой стр., то пропустить его и перейти к след. симв. в файле
          if (opt_s >= 3) continue;
        }
        // ветвление 3 ур. 'если' есть опция 'b' и читаемый симв. - кон. стр.
        // или есть опция 'n' и в обоих случаях номер стр. еще не напечатан, то
        if (((cat_flags->b_min) && (bool_ex == 0) && (buf != '\n')) ||
            (cat_flags->n_min && bool_ex == 0)) {
          // напечатать 6 пробелов, номер строки и отступ таб.
          printf("%6d\t", num_str);
          // инкрементировать значение номера строки
          num_str++;
          // запретить повторную печать номера строки в текущей строке
          bool_ex = 1;
        }
        // ветв. 3 ур. 'если' есть опция 'E' и чит-й симв. соотв-т концу стр.
        if (cat_flags->E_min && buf == '\n') {
          // распечатать символ конца строки
          printf("$");
        }
        // ветв. 3 ур. 'если' есть опция 'e' и чит-й симв. соотв-т концу стр.
        if (cat_flags->e_min && buf == '\n') {
          // распечатать символ конца строки
          printf("$");
          // включить опцию 'v'
          // cat_flags->v_min = 1;
        }
        // ветв 3 ур. 'если' есть флаги 'v' или 't'
        if (cat_flags->v_min || cat_flags->t_min) {
          // ветв. 4 ур. 'если' чит-ый симв. соотв-т знач. по ascii меньше 9
          // или больше 10 и меньше 32
          if (buf < 9 || (buf > 10 && buf < 32)) {
            // присвоить перем-й знач. симв. соотв. знач. по ascii на 64 больше
            // чит-го
            buf += 64;
            // распечатать символ, указанный в кавычках
            printf("^");
            // ветв. 4 ур. 'если иначе' есть опция 't' и чит-ый симв. - это
            // 'tub'
          } else if (cat_flags->t_min && buf == '\t') {
            // распечатать указанный в кавычках симв.
            printf("^");
            // присвоить читаемому симв. значение, указанное в кавычках
            buf = 'I';
            // ветв. 4 ур. 'если иначе' чит-ый симв. соотв-т знач. по ascii 127
          } else if (buf == 127) {
            // присвоить перем-й знач. симв. соотв. знач. по ascii на 64 меньше
            // чит-го
            buf -= 64;
            // распечатать указанный в кавычках симв.
            printf("^");
            // ветв. 4 ур. 'если иначе' чит-ый симв. соотв-т знач. по ascii
            // больше 127 и больше 64
          } else if (buf > 127 && buf <= 159) {
            // распечатать симв. в кавычках и симв.,
            // соотв-й знач. по ascii на 64 меньше знач. чит-го симв.
            buf -= 64;
            printf("M-^");
// если определена ОС Linux
#ifdef __linux__
            // ветв. 4 ур. 'если иначе' чит-ый симв. соотв-т знач. по ascii
            // больше 159 и меньше 255
          } else if (buf > 159 && buf < 255) {
            // распечатать симв. в кавычках и симв.,
            // соотв-й знач. по ascii на 128 меньше знач. чит-го симв.
            buf -= 128;
            printf("M-");
            // ветв. 4 ур. 'если иначе' чит-ый симв. соотв-т знач.
            // по ascii 255
          } else if (buf == 255) {
            // распечатать симв. указанные в кавычках
            printf("M-^?");
#endif
          }
        }
        // ветв. 3 ур. 'если' есть опция 't' и знач. чит-го симв. это - 'tub'
        if (cat_flags->t_min && buf == '\t') {
          // распечатать указанный в кавычках симв.
          printf("^");
          // присвоить читаемому симв. значение, указанное в кавычках
          buf = 'I';
        }
        // ветв. 3 ур. 'если' чит-ый симв. соотв-т концу стр., то
        // включить нумерацию строк, иначе - выключить
        if (buf == '\n') bool_ex = 0;
        // распечатать итерируемый в цикле симв. из потока выв. чит-го файла
        printf("%c", buf);
      }
      // закрыть читаемый файл
      fclose(f_ptr);
      // ветв. 2 ур., 'иначе'
    } else {
      //  распечатать сообщение указанное в кавычках
      fprintf(stderr, "s21_cat: te: No such file or directiry\n");
    }
  }
  return 0;
}